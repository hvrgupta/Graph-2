// Time Complexity : O(N^2)
// Space Complexity : O(N)
// Did this code successfully run on Leetcode : yes
// Any problem you faced while coding this : no

class Solution {
    int[] colors;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        this.colors = new int[n];
        Arrays.fill(this.colors, -1);
        int cl = 0;
        for (int i = 0; i < n; i++) {
            if (colors[i] == -1) {
                dfs(graph, i, cl);
            }
            cl++;
        }

        int[] groups = new int[cl];
        int[] initGroups = new int[cl];

        for (int node : colors) {
            groups[node]++;
        }
        for (int node : initial) {
            int c = colors[node];
            initGroups[c]++;
        }
        int saveNodes = Integer.MAX_VALUE;
        for (int node : initial) {
            int c = colors[node];
            if (initGroups[c] == 1) {
                if (saveNodes == Integer.MAX_VALUE) {
                    saveNodes = node;
                } else if (groups[c] > groups[colors[saveNodes]]) {
                    saveNodes = node;
                } else if (groups[c] == groups[colors[saveNodes]] && node < saveNodes) {
                    saveNodes = node;
                }
            }
        }

        if (saveNodes == Integer.MAX_VALUE) {
            for (int node : initial) {
                saveNodes = Math.min(saveNodes, node);
            }
        }

        return saveNodes;
    }

    private void dfs(int[][] graph, int i, int cl) {
        if (colors[i] != -1)
            return;
        colors[i] = cl;
        for (int j = 0; j < graph.length; j++) {
            if (graph[i][j] == 1) {
                dfs(graph, j, cl);
            }
        }
    }
}